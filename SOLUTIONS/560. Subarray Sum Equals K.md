#HashMap #PrefixSum #Array
[[Prefix sum]]
Given an array of integersÂ `nums`Â and an integerÂ `k`, returnÂ _the total number of subarrays whose sum equals to_Â `k`.

A subarray is a contiguousÂ **non-empty**Â sequence of elements within an array.

**Example 1:**

**Input:** nums = [1,1,1], k = 2
**Output:** 2

**Example 2:**

**Input:** nums = [1,2,3], k = 3
**Output:** 2

**Constraints:**

- `1 <= nums.length <= 2 * 104`
- `-1000 <= nums[i] <= 1000`
- `-107 <= k <= 107`
---
# Solution

## ğŸ”´ **Problem Summary:**

Given an integer array `nums` and an integer `k`, **find the total number of continuous subarrays whose sum equals `k`**.

---

## ğŸ§  Intuition: Brute Force Thinking

You want to **count how many subarrays** (i.e., slices of consecutive elements) add up to exactly `k`.

### ğŸ¯ Naive thought:

Try **all subarrays**, sum them up, and check if they equal `k`.

For example:

```text
nums = [1, 2, 3], k = 3

Subarrays:
[1]      â†’ 1
[1,2]    â†’ 3 âœ…
[1,2,3]  â†’ 6
[2]      â†’ 2
[2,3]    â†’ 5
[3]      â†’ 3 âœ…
```

So answer = 2

---

## âŒ Brute Force Code Idea:

```java
int count = 0;
for (int i = 0; i < nums.length; i++) {
    int sum = 0;
    for (int j = i; j < nums.length; j++) {
        sum += nums[j];
        if (sum == k) count++;
    }
}
```

### Time: O(nÂ²)

Too slow for big inputs.

---

## âš¡ Now, the Killer Intuition (Optimal â€“ Prefix Sum + HashMap)

Hereâ€™s where we flip the game:

### ğŸ”¥ Key Idea:

Keep track of **prefix sums** â€” the sum of all elements up to current index.

Letâ€™s define:

- `prefixSum = sum(nums[0]...nums[i])`
    

Now for any subarray `[i..j]`, the sum is:

```text
sum(i..j) = prefixSum[j] - prefixSum[i-1]
```

So:

```text
prefixSum[j] - prefixSum[i-1] = k  â‡’  prefixSum[i-1] = prefixSum[j] - k
```

### ğŸ§  So the real insight is:

As we move through the array and build up `prefixSum`, we ask:

> Have we seen a prefixSum of `prefixSum - k` before?

If yes â†’ then there's a subarray ending at `j` with sum `k`.

---

### ğŸ’¼ HashMap to the Rescue:

- Use a HashMap to store: `{prefixSum: count}`
    
- Initialize it with `{0: 1}` â†’ this handles the case when a prefixSum directly equals `k`.
    

---

### âœ… Java Code (Optimal):

```java
public int subarraySum(int[] nums, int k) {
    Map<Integer, Integer> map = new HashMap<>();
    map.put(0, 1);

    int sum = 0, count = 0;

    for (int num : nums) {
        sum += num;

        if (map.containsKey(sum - k)) {
            count += map.get(sum - k);
        }

        map.put(sum, map.getOrDefault(sum, 0) + 1);
    }

    return count;
}
```

---

### ğŸ” Example Trace:

```text
nums = [1, 1, 1], k = 2

prefixSum trace:
sum = 1 â†’ map has (1-2)= -1 âŒ
sum = 2 â†’ map has (2-2)= 0 âœ… count = 1
sum = 3 â†’ map has (3-2)= 1 âœ… count = 2
```

---

### â±ï¸ Time & Space:

- **Time:** O(n)
    
- **Space:** O(n)
    

---

## ğŸ“˜ Recap of Concepts:

|Concept|Purpose|
|---|---|
|Prefix Sum|Convert subarray sum to simple math|
|HashMap|Fast lookup of `prefixSum - k`|
|`{0:1}` Trick|Handles exact match from start index|

---
